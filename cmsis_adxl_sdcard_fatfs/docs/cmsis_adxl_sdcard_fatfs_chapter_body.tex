\chapter{From Raw Sectors to Files}
\label{ch:fatfs-followon}

This chapter is a continuation of Chapter~\ref{ch:raw-sd} for
\texttt{cmsis\_adxl\_sdcard\_fatfs}. It assumes you already understand:
\begin{itemize}[leftmargin=*]
\item SPI transaction framing and chip-select timing,
\item SD card SPI initialization (CMD0/CMD8/ACMD41/CMD58), and
\item 512-byte block read/write primitives.
\end{itemize}

What changes here is \textbf{where writes are targeted}: not fixed LBAs, but a named file
(\texttt{0:adxl\_log.csv}) managed by FatFs.

\section{Design Delta from the Raw-Sector Project}

The two projects share the same hardware split:
\begin{itemize}[leftmargin=*]
\item SPI1 for ADXL345
\item SPI2 for microSD
\item USART2 TX for live monitoring
\end{itemize}

The key software delta is layering:
\begin{enumerate}[leftmargin=*]
\item SD SPI driver still provides sector-level operations.
\item A \texttt{diskio} port maps FatFs requests to those sector operations.
\item Application code calls a logger module (\texttt{fatfs\_log}) that wraps FatFs file APIs.
\end{enumerate}

\section{Application Flow with FatFs}

The main loop still reads ADXL and prints UART telemetry, but SD file operations are
centralized in \texttt{fatfs\_log\_init()} and \texttt{fatfs\_log\_append\_line()}.

\begin{lstlisting}[style=cstyle,caption={Main FatFs logging flow (condensed from src/main.c)}]
if (!system_init()) {
  while (1) {
    printf("system_init failed\n");
    systick_msec_delay(500);
  }
}

bool sd_logging_enabled = fatfs_log_init();
if (!sd_logging_enabled) {
  while (1) {
    printf("FatFs logger init failed\n");
    systick_msec_delay(500);
  }
}

while (1) {
  // read ADXL sample and convert to mg
  // ...
  char line[128];
  int n = snprintf(line, sizeof(line), "%" PRIu32 ",%" PRId32 ",%" PRId32 ",%" PRId32 "\r\n", ...);

  if (n > 0) {
    printf("sample=%" PRIu32 " ...\n", ...); // UART remains active
    if (sd_logging_enabled && !fatfs_log_append_line(line)) {
      printf("FatFs write failed; disabling SD logging\n");
      sd_logging_enabled = false;
    }
  }
}
\end{lstlisting}

\section{Why \texttt{f\_sync()} Every N Samples?}

FatFs and SD cards buffer state. If power drops before sync/close,
recent data and metadata can be lost.

This project uses a periodic sync policy (every 10 samples):
\begin{itemize}[leftmargin=*]
\item lower loss window than syncing only at shutdown,
\item less overhead than syncing every single line,
\item practical for interactive logging while debugging firmware.
\end{itemize}

\section{The Disk I/O Bridge: FatFs to SPI Blocks}

FatFs is filesystem logic. It still needs low-level block device hooks.
That contract lives in \texttt{src/fatfs/diskio\_port.c}.

\begin{lstlisting}[style=cstyle,caption={Core diskio mapping in this project}]
static DSTATUS sd_status = STA_NOINIT;

DSTATUS disk_initialize(BYTE pdrv) {
  if (pdrv != 0U) return STA_NOINIT;
  sd_status = sdcard_spi_init() ? 0U : STA_NOINIT;
  return sd_status;
}

DSTATUS disk_status(BYTE pdrv) {
  if (pdrv != 0U) return STA_NOINIT;
  return sd_status;
}

DRESULT disk_read(BYTE pdrv, BYTE *buff, LBA_t sector, UINT count) {
  if ((pdrv != 0U) || (buff == 0) || (count == 0U)) return RES_PARERR;
  if ((sd_status & STA_NOINIT) != 0U) return RES_NOTRDY;
  for (UINT i = 0; i < count; i++) {
    if (!sdcard_spi_read_block((uint32_t)sector + i, &buff[i * 512U])) {
      sd_status = STA_NOINIT;
      return RES_ERROR;
    }
  }
  return RES_OK;
}

DRESULT disk_write(BYTE pdrv, const BYTE *buff, LBA_t sector, UINT count) {
  if ((pdrv != 0U) || (buff == 0) || (count == 0U)) return RES_PARERR;
  if ((sd_status & STA_NOINIT) != 0U) return RES_NOTRDY;
  for (UINT i = 0; i < count; i++) {
    if (!sdcard_spi_write_block((uint32_t)sector + i, &buff[i * 512U])) {
      sd_status = STA_NOINIT;
      return RES_ERROR;
    }
  }
  return RES_OK;
}

DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void *buff) {
  if (cmd == GET_SECTOR_COUNT) {
    return sdcard_spi_get_sector_count((uint32_t *)buff) ? RES_OK : RES_ERROR;
  }
  // ...
}
\end{lstlisting}

\noindent
Conceptually, this layer is the most important addition versus the raw-sector project.
It lets FatFs treat your SD SPI driver as a generic block device.

\section{SD Driver Changes for FatFs}

Compared with the raw-sector project, the SD SPI module adds block read support:
\begin{itemize}[leftmargin=*]
\item \texttt{CMD17} single-block read path,
\item wait for start token \texttt{0xFE},
\item receive exactly 512 bytes plus 2 CRC bytes.
\item \texttt{CMD9} CSD read path to derive real sector count for \texttt{GET\_SECTOR\_COUNT}.
\end{itemize}

\subsection*{What the SD Commands Mean}
\begin{itemize}[leftmargin=*]
\item \texttt{CMD0}: reset card into SPI idle state.
\item \texttt{CMD8}: interface-condition check for SD v2 cards.
\item \texttt{CMD9}: read CSD register; used to compute total 512-byte logical sectors.
\item \texttt{CMD55} + \texttt{ACMD41}: app-command prefix and initialization pair used to leave idle state.
\item \texttt{CMD58}: read OCR to confirm power-up status and capacity mode.
\item \texttt{CMD16}: set block length on SDSC cards when needed.
\item \texttt{CMD17}: read one 512-byte block (single-block read).
\item \texttt{CMD24}: write one 512-byte block (single-block write), used under FatFs via disk I/O write path.
\end{itemize}

\begin{lstlisting}[style=cstyle,caption={Read path in SPI mode (condensed)}]
static bool sd_read_data_block(uint8_t token, uint8_t *data, uint32_t size, uint32_t max_wait);

bool sdcard_spi_read_block(uint32_t lba, uint8_t *data_512) {
  // ... send CMD17 ...
  if (!sd_read_data_block(0xFEU, data_512, 512U, 100000U)) return false;
  return true;
}

// During init, CMD9 returns the CSD payload (16 bytes).
if (!sd_send_cmd(CMD9, 0U, 0x01U, &r1)) return false;
if (!sd_read_data_block(0xFEU, csd, 16U, 100000U)) return false;
if (!sd_parse_sector_count_from_csd(csd, &sd_sector_count)) return false;
\end{lstlisting}

\section{CSV Format and Host Workflow}

Because this project writes through FatFs, the card remains host-friendly:
\begin{itemize}[leftmargin=*]
\item file: \texttt{adxl\_log.csv}
\item header: \texttt{sample,ax\_mg,ay\_mg,az\_mg}
\item rows: one sample per line with CRLF endings
\end{itemize}

That means you can remove the card and open the file directly in spreadsheet or analysis tools,
which is the practical advantage over raw fixed-LBA logging.

\section{Error Behavior}

The application handles errors in two categories:
\begin{itemize}[leftmargin=*]
\item \textbf{startup-fatal}: \texttt{system\_init()} or \texttt{fatfs\_log\_init()} failures stay in a visible error loop.
\item \textbf{runtime-nonfatal}: append/sync failures disable SD logging and keep UART sample output active.
\end{itemize}

This preserves observability while exposing storage problems in real time.

\section{Testing Checklist}

\begin{enumerate}[leftmargin=*]
\item Format SD card as FAT32.
\item Flash firmware and open UART at 115200 8N1.
\item Confirm boot banner and sample stream.
\item Power cycle once to verify append behavior (file grows, no header duplication).
\item Remove card and inspect \texttt{adxl\_log.csv} on host.
\end{enumerate}

\chapter*{Appendix: Relationship to the Previous Chapter}

Use Chapter~\ref{ch:raw-sd} for SPI/SD protocol grounding:
\begin{itemize}[leftmargin=*]
\item Raw-sector chapter in this combined book (label: \texttt{ch:raw-sd})
\end{itemize}

Use Chapter~\ref{ch:fatfs-followon} for filesystem integration concepts:
\begin{itemize}[leftmargin=*]
\item FatFs chapter in this combined book (label: \texttt{ch:fatfs-followon})
\end{itemize}
